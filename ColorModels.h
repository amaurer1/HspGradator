//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// ColorModels.h
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Copyright (c) 2020 Adrian Maurer. All rights reserved.
// Distributed under the MIT software license (http://www.opensource.org/licenses/mit-license.php).
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "Color.h"
#include <algorithm>
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
using TRgb = TColor<T>;
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
class THsv
{
// ELEMENT DATA
public:
	T h, s, v;

// CONSTRUCTION / DESTRUCTION / ASSIGNMENT
public:
	THsv() : h(T(0.0)), s(T(0.0)), v(T(0.0)) {}
	THsv(const T vh, const T vs, const T vv) : h(vh), s(vs), v(vv) {}
};
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
class THsl
{
// ELEMENT DATA
public:
	T h, s, l;

// CONSTRUCTION / DESTRUCTION / ASSIGNMENT
public:
	THsl() : h(T(0.0)), s(T(0.0)), l(T(0.0)) {}
	THsl(const T vh, const T vs, const T vl) : h(vh), s(vs), l(vl) {}
};
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
class THsg
{
// ELEMENT DATA
public:
	T h, s, g;

// CONSTRUCTION / DESTRUCTION / ASSIGNMENT
public:
	THsg() : h(T(0.0)), s(T(0.0)), g(T(0.0)) {}
	THsg(const T vh, const T vs, const T vg) : h(vh), s(vs), g(vg) {}
};
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
class THsp
{
// ELEMENT DATA
public:
	T h, s, p;

// CONSTRUCTION / DESTRUCTION / ASSIGNMENT
public:
	THsp() : h(T(0.0)), s(T(0.0)), p(T(0.0)) {}
	THsp(const T vh, const T vs, const T vp) : h(vh), s(vs), p(vp) {}
};
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline bool isInRange(const T v1, const T v2, const T v3)
{
	return v1 >= T(0.0) && v1 <= T(1.0) && v2 >= T(0.0) && v2 <= T(1.0) && v3 >= T(0.0) && v3 <= T(1.0);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline TRgb<T> calcHueColor(const T h)
{
	const T v = h < T(1.0) ? h * T(6.0) : T(0.0);
	const int i = static_cast<int>(v);
	const T f = v - i;
	switch (i)
	{
		case 0: return {T(1.0), f, T(0.0)};
		case 1: return {T(1.0) - f, T(1.0), T(0.0)};
		case 2: return {T(0.0), T(1.0), f};
		case 3: return {T(0.0), T(1.0) - f, T(1.0)};
		case 4: return {f, T(0.0), T(1.0)};
		case 5: return {T(1.0), T(0.0), T(1.0) - f};
		default: return {};
	}
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline TRgb<T> convertToRgb(const THsv<T>& c)
{
	if (isInRange(c.h, c.s, c.v))
	{
		return (calcHueColor(c.h) * c.s + (T(1.0) - c.s)) * c.v;
	}
	return {};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline TRgb<T> convertToRgb(const THsl<T>& c)
{
	if (isInRange(c.h, c.s, c.l))
	{
		const TRgb<T> t(calcHueColor(c.h) * c.s + T(0.5) * (T(1.0) - c.s));
		if (c.l < T(0.5))
		{
			return t * c.l / T(0.5);
		}
		else
		{
			const T l = (c.l - T(0.5)) / T(0.5);
			return t * (T(1.0) - l) + l;
		}
	}
	return {};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline TRgb<T> convertToRgb(const THsg<T>& c)
{
	if (isInRange(c.h, c.s, c.g))
	{
		return calcHueColor(c.h) * c.s + c.g * (T(1.0) - c.s);
	}
	return {};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline T calcPerceivedBrightness(const TRgb<T>& c)
{
	return c.r * T(0.299) + c.g * T(0.587) + c.b * T(0.114);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline TRgb<T> convertToRgb(const THsp<T>& c)
{
	if (isInRange(c.h, c.s, c.p))
	{
		const TRgb<T> hc(calcHueColor(c.h));
		const T hcpb = calcPerceivedBrightness(hc);
		const TRgb<T> t(hc * c.s + hcpb * (T(1.0) - c.s));
		if (c.p < hcpb)
		{
			return t * c.p / hcpb;
		}
		else
		{
			const T pb = (c.p - hcpb) / (T(1.0) - hcpb);
			return t * (T(1.0) - pb) + pb;
		}
	}
	return {};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline T getMax(const TRgb<T> c)
{
	return (std::max)((std::max)(c.r, c.g), c.b);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline T getMin(const TRgb<T> c)
{
	return (std::min)((std::min)(c.r, c.g), c.b);
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline T calcColorHue(const TRgb<T>& c, const T max, const T d)
{
	T h = T(0.0);
	if (c.r == max) h = (c.g - c.b) / d;
	else if (c.g == max) h = T(2.0) + (c.b - c.r) / d;
	else if (c.b == max) h = T(4.0) + (c.r - c.g) / d;
	h /= T(6.0);
	if (h < T(0.0)) h += T(1.0);
	return h;
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline THsv<T> convertToHsv(const TRgb<T>& c)
{
	if (isInRange(c.r, c.g, c.b))
	{
		if (const T max = getMax(c))
		{
			const T min = getMin(c);
			if (const T d = max - min)
			{
				return {calcColorHue(c, max, d), d / max, max};
			}
			return {T(0.0), T(0.0), max};
		}
	}
	return {};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline THsl<T> convertToHsl(const TRgb<T>& c)
{
	if (isInRange(c.r, c.g, c.b))
	{
		if (const T max = getMax(c))
		{
			const T min = getMin(c);
			const T l = (max + min) / T(2.0);
			if (const T d = max - min)
			{
				const T s = l <= T(0.5) ? d / (l / T(0.5)) : d / (T(1.0) - (l - T(0.5)) / T(0.5));
				return {calcColorHue(c, max, d), s < T(1.0) ? s : T(1.0), l};
			}
			return {T(0.0), T(0.0), l};
		}
	}
	return {};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline THsg<T> convertToHsg(const TRgb<T>& c)
{
	if (isInRange(c.r, c.g, c.b))
	{
		if (const T max = getMax(c))
		{
			const T min = getMin(c);
			if (const T d = max - min)
			{
				const T g = d == T(1.0) ? T(0.0) : min / (T(1.0) - d);
				return {calcColorHue(c, max, d), d, g < T(1.0) ? g : T(1.0)};
			}
			return {T(0.0), T(0.0), max};
		}
	}
	return {};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template <class T>
inline THsp<T> convertToHsp(const TRgb<T>& c)
{
	if (isInRange(c.r, c.g, c.b))
	{
		if (const T max = getMax(c))
		{
			const T min = getMin(c);
			const T pb = calcPerceivedBrightness(c);
			if (const T d = max - min)
			{
				const T h = calcColorHue(c, max, d);
				const T hcpb = calcPerceivedBrightness(calcHueColor(h));
				const T s = pb <= hcpb ? d / (pb / hcpb) : d / (T(1.0) - (pb - hcpb) / (T(1.0) - hcpb));
				return {h, s < T(1.0) ? s : T(1.0), pb};
			}
			return {T(0.0), T(0.0), pb};
		}
	}
	return {};
}
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
